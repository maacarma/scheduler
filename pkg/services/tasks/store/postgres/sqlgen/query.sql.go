// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlgen

import (
	"context"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
  url, method, namespace, params, headers, body, start_unix, end_unix, interval, paused
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING _id
`

type CreateTaskParams struct {
	Url       string `json:"url"`
	Method    string `json:"method"`
	Namespace string `json:"namespace"`
	Params    []byte `json:"params"`
	Headers   []byte `json:"headers"`
	Body      []byte `json:"body"`
	StartUnix int64  `json:"start_unix"`
	EndUnix   int64  `json:"end_unix"`
	Interval  string `json:"interval"`
	Paused    bool   `json:"paused"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.Url,
		arg.Method,
		arg.Namespace,
		arg.Params,
		arg.Headers,
		arg.Body,
		arg.StartUnix,
		arg.EndUnix,
		arg.Interval,
		arg.Paused,
	)
	var _id int64
	err := row.Scan(&_id)
	return _id, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks
WHERE _id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, ID int64) error {
	_, err := q.db.Exec(ctx, deleteTask, ID)
	return err
}

const getActiveTasks = `-- name: GetActiveTasks :many
SELECT _id, url, method, namespace, params, headers, body, start_unix, end_unix, interval, paused FROM tasks
WHERE end_unix >= $1 AND NOT paused
`

func (q *Queries) GetActiveTasks(ctx context.Context, endUnix int64) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getActiveTasks, endUnix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Method,
			&i.Namespace,
			&i.Params,
			&i.Headers,
			&i.Body,
			&i.StartUnix,
			&i.EndUnix,
			&i.Interval,
			&i.Paused,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT _id, url, method, namespace, params, headers, body, start_unix, end_unix, interval, paused FROM tasks
WHERE _id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, ID int64) (*Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Method,
		&i.Namespace,
		&i.Params,
		&i.Headers,
		&i.Body,
		&i.StartUnix,
		&i.EndUnix,
		&i.Interval,
		&i.Paused,
	)
	return &i, err
}

const getTasks = `-- name: GetTasks :many
SELECT _id, url, method, namespace, params, headers, body, start_unix, end_unix, interval, paused FROM tasks
`

func (q *Queries) GetTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Method,
			&i.Namespace,
			&i.Params,
			&i.Headers,
			&i.Body,
			&i.StartUnix,
			&i.EndUnix,
			&i.Interval,
			&i.Paused,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByNamespace = `-- name: GetTasksByNamespace :many
SELECT _id, url, method, namespace, params, headers, body, start_unix, end_unix, interval, paused FROM tasks
WHERE namespace = $1
`

func (q *Queries) GetTasksByNamespace(ctx context.Context, namespace string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getTasksByNamespace, namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Method,
			&i.Namespace,
			&i.Params,
			&i.Headers,
			&i.Body,
			&i.StartUnix,
			&i.EndUnix,
			&i.Interval,
			&i.Paused,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks
SET paused = $2
WHERE _id = $1
`

type UpdateTaskStatusParams struct {
	ID     int64 `json:"_id"`
	Paused bool  `json:"paused"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Paused)
	return err
}
